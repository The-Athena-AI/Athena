{"ast":null,"code":"\"use client\";\n\n// packages/react/src/provider.tsx\nimport Lenis from \"lenis\";\nimport { createContext, forwardRef, useCallback, useEffect as useEffect2, useImperativeHandle, useRef, useState as useState2 } from \"react\";\n\n// packages/react/src/store.ts\nimport { useEffect, useState } from \"react\";\nvar Store = class {\n  constructor(state) {\n    this.state = state;\n  }\n  listeners = [];\n  set(state) {\n    this.state = state;\n    for (let listener of this.listeners) {\n      listener(this.state);\n    }\n  }\n  subscribe(listener) {\n    this.listeners = [...this.listeners, listener];\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n  get() {\n    return this.state;\n  }\n};\nfunction useStore(store) {\n  const [state, setState] = useState(store.get());\n  useEffect(() => {\n    return store.subscribe(state2 => setState(state2));\n  }, [store]);\n  return state;\n}\n\n// packages/react/src/provider.tsx\nimport { jsx } from \"react/jsx-runtime\";\nvar LenisContext = createContext(null);\nvar rootLenisContextStore = new Store(null);\nvar ReactLenis = forwardRef(({\n  children,\n  root = false,\n  options = {},\n  className,\n  autoRaf = true,\n  props\n}, ref) => {\n  const wrapperRef = useRef(null);\n  const contentRef = useRef(null);\n  const [lenis, setLenis] = useState2(void 0);\n  useImperativeHandle(ref, () => ({\n    wrapper: wrapperRef.current,\n    content: contentRef.current,\n    lenis\n  }), [lenis]);\n  useEffect2(() => {\n    const lenis2 = new Lenis({\n      ...options,\n      ...(!root && {\n        wrapper: wrapperRef.current,\n        content: contentRef.current\n      }),\n      autoRaf: options?.autoRaf ?? autoRaf\n      // this is to avoid breaking the autoRaf prop if it's still used (require breaking change)\n    });\n    setLenis(lenis2);\n    return () => {\n      lenis2.destroy();\n      setLenis(void 0);\n    };\n  }, [root, JSON.stringify(options)]);\n  const callbacksRefs = useRef([]);\n  const addCallback = useCallback((callback, priority) => {\n    callbacksRefs.current.push({\n      callback,\n      priority\n    });\n    callbacksRefs.current.sort((a, b) => a.priority - b.priority);\n  }, []);\n  const removeCallback = useCallback(callback => {\n    callbacksRefs.current = callbacksRefs.current.filter(cb => cb.callback !== callback);\n  }, []);\n  useEffect2(() => {\n    if (root && lenis) {\n      rootLenisContextStore.set({\n        lenis,\n        addCallback,\n        removeCallback\n      });\n      return () => rootLenisContextStore.set(null);\n    }\n  }, [root, lenis, addCallback, removeCallback]);\n  useEffect2(() => {\n    if (!lenis) return;\n    const onScroll = data => {\n      for (let i = 0; i < callbacksRefs.current.length; i++) {\n        callbacksRefs.current[i]?.callback(data);\n      }\n    };\n    lenis.on(\"scroll\", onScroll);\n    return () => {\n      lenis.off(\"scroll\", onScroll);\n    };\n  }, [lenis]);\n  return /* @__PURE__ */jsx(LenisContext.Provider, {\n    value: {\n      lenis,\n      addCallback,\n      removeCallback\n    },\n    children: root ? children : /* @__PURE__ */jsx(\"div\", {\n      ref: wrapperRef,\n      className,\n      ...props,\n      children: /* @__PURE__ */jsx(\"div\", {\n        ref: contentRef,\n        children\n      })\n    })\n  });\n});\n\n// packages/react/src/use-lenis.ts\nimport { useContext, useEffect as useEffect3 } from \"react\";\nvar fallbackContext = {};\nfunction useLenis(callback, deps = [], priority = 0) {\n  const localContext = useContext(LenisContext);\n  const rootContext = useStore(rootLenisContextStore);\n  const currentContext = localContext ?? rootContext ?? fallbackContext;\n  const {\n    lenis,\n    addCallback,\n    removeCallback\n  } = currentContext;\n  useEffect3(() => {\n    if (!callback || !addCallback || !removeCallback || !lenis) return;\n    addCallback(callback, priority);\n    callback(lenis);\n    return () => {\n      removeCallback(callback);\n    };\n  }, [lenis, addCallback, removeCallback, priority, ...deps]);\n  return lenis;\n}\nexport { ReactLenis as Lenis, ReactLenis, ReactLenis as default, useLenis };","map":{"version":3,"names":["Lenis","createContext","forwardRef","useCallback","useEffect","useEffect2","useImperativeHandle","useRef","useState","useState2","Store","constructor","state","listeners","set","listener","subscribe","filter","l","get","useStore","store","setState","state2","jsx","LenisContext","rootLenisContextStore","ReactLenis","children","root","options","className","autoRaf","props","ref","wrapperRef","contentRef","lenis","setLenis","wrapper","current","content","lenis2","destroy","JSON","stringify","callbacksRefs","addCallback","callback","priority","push","sort","a","b","removeCallback","cb","onScroll","data","i","length","on","off","Provider","value","useContext","useEffect3","fallbackContext","useLenis","deps","localContext","rootContext","currentContext"],"sources":["/Users/prajnyiqueghimire/Pandora-s-Box/hades/node_modules/lenis/packages/react/src/provider.tsx","/Users/prajnyiqueghimire/Pandora-s-Box/hades/node_modules/lenis/packages/react/src/store.ts","/Users/prajnyiqueghimire/Pandora-s-Box/hades/node_modules/lenis/packages/react/src/use-lenis.ts"],"sourcesContent":["import Lenis, { type ScrollCallback } from 'lenis'\r\nimport {\r\n  createContext,\r\n  forwardRef,\r\n  useCallback,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useRef,\r\n  useState,\r\n} from 'react'\r\nimport { Store } from './store'\r\nimport type { LenisContextValue, LenisProps, LenisRef } from './types'\r\n\r\nexport const LenisContext = createContext<LenisContextValue | null>(null)\r\n\r\n/**\r\n * The root store for the lenis context\r\n *\r\n * This store serves as a fallback for the context if it is not available\r\n * and allows us to use the global lenis instance above a provider\r\n */\r\nexport const rootLenisContextStore = new Store<LenisContextValue | null>(null)\r\n\r\n/**\r\n * React component to setup a Lenis instance\r\n */\r\nexport const ReactLenis = forwardRef<LenisRef, LenisProps>(\r\n  (\r\n    {\r\n      children,\r\n      root = false,\r\n      options = {},\r\n      className,\r\n      autoRaf = true,\r\n      props,\r\n    }: LenisProps,\r\n    ref\r\n  ) => {\r\n    const wrapperRef = useRef<HTMLDivElement | null>(null)\r\n    const contentRef = useRef<HTMLDivElement | null>(null)\r\n\r\n    const [lenis, setLenis] = useState<Lenis | undefined>(undefined)\r\n\r\n    // Setup ref\r\n    useImperativeHandle(\r\n      ref,\r\n      () => ({\r\n        wrapper: wrapperRef.current,\r\n        content: contentRef.current,\r\n        lenis,\r\n      }),\r\n      [lenis]\r\n    )\r\n\r\n    // Setup lenis instance\r\n    useEffect(() => {\r\n      const lenis = new Lenis({\r\n        ...options,\r\n        ...(!root && {\r\n          wrapper: wrapperRef.current!,\r\n          content: contentRef.current!,\r\n        }),\r\n        autoRaf: options?.autoRaf ?? autoRaf, // this is to avoid breaking the autoRaf prop if it's still used (require breaking change)\r\n      })\r\n\r\n      setLenis(lenis)\r\n\r\n      return () => {\r\n        lenis.destroy()\r\n        setLenis(undefined)\r\n      }\r\n    }, [root, JSON.stringify(options)])\r\n\r\n    // Handle callbacks\r\n    const callbacksRefs = useRef<\r\n      {\r\n        callback: ScrollCallback\r\n        priority: number\r\n      }[]\r\n    >([])\r\n\r\n    const addCallback: LenisContextValue['addCallback'] = useCallback(\r\n      (callback, priority) => {\r\n        callbacksRefs.current.push({ callback, priority })\r\n        callbacksRefs.current.sort((a, b) => a.priority - b.priority)\r\n      },\r\n      []\r\n    )\r\n\r\n    const removeCallback: LenisContextValue['removeCallback'] = useCallback(\r\n      (callback) => {\r\n        callbacksRefs.current = callbacksRefs.current.filter(\r\n          (cb) => cb.callback !== callback\r\n        )\r\n      },\r\n      []\r\n    )\r\n\r\n    // This makes sure to set the global context if the root is true\r\n    useEffect(() => {\r\n      if (root && lenis) {\r\n        rootLenisContextStore.set({ lenis, addCallback, removeCallback })\r\n\r\n        return () => rootLenisContextStore.set(null)\r\n      }\r\n    }, [root, lenis, addCallback, removeCallback])\r\n\r\n    // Setup callback listeners\r\n    useEffect(() => {\r\n      if (!lenis) return\r\n\r\n      const onScroll: ScrollCallback = (data) => {\r\n        for (let i = 0; i < callbacksRefs.current.length; i++) {\r\n          callbacksRefs.current[i]?.callback(data)\r\n        }\r\n      }\r\n\r\n      lenis.on('scroll', onScroll)\r\n\r\n      return () => {\r\n        lenis.off('scroll', onScroll)\r\n      }\r\n    }, [lenis])\r\n\r\n    return (\r\n      <LenisContext.Provider\r\n        value={{ lenis: lenis!, addCallback, removeCallback }}\r\n      >\r\n        {root ? (\r\n          children\r\n        ) : (\r\n          <div ref={wrapperRef} className={className} {...props}>\r\n            <div ref={contentRef}>{children}</div>\r\n          </div>\r\n        )}\r\n      </LenisContext.Provider>\r\n    )\r\n  }\r\n)\r\n","import { useEffect, useState } from 'react'\r\n\r\ntype Listener<S> = (state: S) => void\r\n\r\nexport class Store<S> {\r\n  private listeners: Listener<S>[] = []\r\n\r\n  constructor(private state: S) {}\r\n\r\n  set(state: S) {\r\n    this.state = state\r\n\r\n    for (let listener of this.listeners) {\r\n      listener(this.state)\r\n    }\r\n  }\r\n\r\n  subscribe(listener: Listener<S>) {\r\n    this.listeners = [...this.listeners, listener]\r\n    return () => {\r\n      this.listeners = this.listeners.filter((l) => l !== listener)\r\n    }\r\n  }\r\n\r\n  get() {\r\n    return this.state\r\n  }\r\n}\r\n\r\nexport function useStore<S>(store: Store<S>) {\r\n  const [state, setState] = useState(store.get())\r\n\r\n  useEffect(() => {\r\n    return store.subscribe((state) => setState(state))\r\n  }, [store])\r\n\r\n  return state\r\n}\r\n","import type { ScrollCallback } from 'lenis'\r\nimport { useContext, useEffect } from 'react'\r\nimport { LenisContext, rootLenisContextStore } from './provider'\r\nimport { useStore } from './store'\r\nimport type { LenisContextValue } from './types'\r\n\r\n// Fall back to an empty object if both context and store are not available\r\nconst fallbackContext: Partial<LenisContextValue> = {}\r\n\r\n/**\r\n * Hook to access the Lenis instance and its methods\r\n *\r\n * @example <caption>Scroll callback</caption>\r\n *          useLenis((lenis) => {\r\n *            if (lenis.isScrolling) {\r\n *              console.log('Scrolling...')\r\n *            }\r\n *\r\n *            if (lenis.progress === 1) {\r\n *              console.log('At the end!')\r\n *            }\r\n *          })\r\n *\r\n * @example <caption>Scroll callback with dependencies</caption>\r\n *          useLenis((lenis) => {\r\n *            if (lenis.isScrolling) {\r\n *              console.log('Scrolling...', someDependency)\r\n *            }\r\n *          }, [someDependency])\r\n * @example <caption>Scroll callback with priority</caption>\r\n *          useLenis((lenis) => {\r\n *            if (lenis.isScrolling) {\r\n *              console.log('Scrolling...')\r\n *            }\r\n *          }, [], 1)\r\n * @example <caption>Instance access</caption>\r\n *          const lenis = useLenis()\r\n *\r\n *          handleClick() {\r\n *            lenis.scrollTo(100, {\r\n *              lerp: 0.1,\r\n *              duration: 1,\r\n *              easing: (t) => t,\r\n *              onComplete: () => {\r\n *                console.log('Complete!')\r\n *              }\r\n *            })\r\n *          }\r\n */\r\nexport function useLenis(\r\n  callback?: ScrollCallback,\r\n  deps: any[] = [],\r\n  priority = 0\r\n) {\r\n  // Try to get the lenis instance from the context first\r\n  const localContext = useContext(LenisContext)\r\n  // Fall back to the root store if the context is not available\r\n  const rootContext = useStore(rootLenisContextStore)\r\n  // Fall back to the fallback context if all else fails\r\n  const currentContext = localContext ?? rootContext ?? fallbackContext\r\n\r\n  const { lenis, addCallback, removeCallback } = currentContext\r\n\r\n  useEffect(() => {\r\n    if (!callback || !addCallback || !removeCallback || !lenis) return\r\n\r\n    addCallback(callback, priority)\r\n    callback(lenis)\r\n\r\n    return () => {\r\n      removeCallback(callback)\r\n    }\r\n  }, [lenis, addCallback, removeCallback, priority, ...deps])\r\n\r\n  return lenis\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}